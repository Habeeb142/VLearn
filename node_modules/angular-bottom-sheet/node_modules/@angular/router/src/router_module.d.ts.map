{"version":3,"file":"router_module.d.ts","sources":["router_module.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { HashLocationStrategy, Location, PathLocationStrategy, PlatformLocation, ViewportScroller } from '@angular/common';\nimport { ApplicationRef, Compiler, ComponentRef, InjectionToken, Injector, ModuleWithProviders, NgModuleFactoryLoader, NgProbeToken, Provider } from '@angular/core';\nimport { Route, Routes } from './config';\nimport { RouteReuseStrategy } from './route_reuse_strategy';\nimport { ErrorHandler, Router } from './router';\nimport { ChildrenOutletContexts } from './router_outlet_context';\nimport { RouterScroller } from './router_scroller';\nimport { ActivatedRoute } from './router_state';\nimport { UrlHandlingStrategy } from './url_handling_strategy';\nimport { UrlSerializer, UrlTree } from './url_tree';\n/**\n * @description\n *\n * Is used in DI to configure the router.\n *\n * @publicApi\n */\nexport declare const ROUTER_CONFIGURATION: InjectionToken<ExtraOptions>;\n/**\n * @docsNotRequired\n */\nexport declare const ROUTER_FORROOT_GUARD: InjectionToken<void>;\nexport declare const ROUTER_PROVIDERS: Provider[];\nexport declare function routerNgProbeToken(): NgProbeToken;\n/**\n * @usageNotes\n *\n * RouterModule can be imported multiple times: once per lazily-loaded bundle.\n * Since the router deals with a global shared resource--location, we cannot have\n * more than one router service active.\n *\n * That is why there are two ways to create the module: `RouterModule.forRoot` and\n * `RouterModule.forChild`.\n *\n * * `forRoot` creates a module that contains all the directives, the given routes, and the router\n *   service itself.\n * * `forChild` creates a module that contains all the directives and the given routes, but does not\n *   include the router service.\n *\n * When registered at the root, the module should be used as follows\n *\n * ```\n * @NgModule({\n *   imports: [RouterModule.forRoot(ROUTES)]\n * })\n * class MyNgModule {}\n * ```\n *\n * For submodules and lazy loaded submodules the module should be used as follows:\n *\n * ```\n * @NgModule({\n *   imports: [RouterModule.forChild(ROUTES)]\n * })\n * class MyNgModule {}\n * ```\n *\n * @description\n *\n * Adds router directives and providers.\n *\n * Managing state transitions is one of the hardest parts of building applications. This is\n * especially true on the web, where you also need to ensure that the state is reflected in the URL.\n * In addition, we often want to split applications into multiple bundles and load them on demand.\n * Doing this transparently is not trivial.\n *\n * The Angular router solves these problems. Using the router, you can declaratively specify\n * application states, manage state transitions while taking care of the URL, and load bundles on\n * demand.\n *\n * [Read this developer guide](https://angular.io/docs/ts/latest/guide/router.html) to get an\n * overview of how the router should be used.\n *\n * @publicApi\n */\nexport declare class RouterModule {\n    constructor(guard: any, router: Router);\n    /**\n     * Creates a module with all the router providers and directives. It also optionally sets up an\n     * application listener to perform an initial navigation.\n     *\n     * Configuration Options:\n     *\n     * * `enableTracing` Toggles whether the router should log all navigation events to the console.\n     * * `useHash` Enables the location strategy that uses the URL fragment instead of the history\n     * API.\n     * * `initialNavigation` Disables the initial navigation.\n     * * `errorHandler` Defines a custom error handler for failed navigations.\n     * * `preloadingStrategy` Configures a preloading strategy. See `PreloadAllModules`.\n     * * `onSameUrlNavigation` Define what the router should do if it receives a navigation request to\n     * the current URL.\n     * * `scrollPositionRestoration` Configures if the scroll position needs to be restored when\n     * navigating back.\n     * * `anchorScrolling` Configures if the router should scroll to the element when the url has a\n     * fragment.\n     * * `scrollOffset` Configures the scroll offset the router will use when scrolling to an element.\n     * * `paramsInheritanceStrategy` Defines how the router merges params, data and resolved data from\n     * parent to child routes.\n     * * `malformedUriErrorHandler` Defines a custom malformed uri error handler function. This\n     * handler is invoked when encodedURI contains invalid character sequences.\n     * * `urlUpdateStrategy` Defines when the router updates the browser URL. The default behavior is\n     * to update after successful navigation.\n     * * `relativeLinkResolution` Enables the correct relative link resolution in components with\n     * empty paths.\n     *\n     * See `ExtraOptions` for more details about the above options.\n    */\n    static forRoot(routes: Routes, config?: ExtraOptions): ModuleWithProviders<RouterModule>;\n    /**\n     * Creates a module with all the router directives and a provider registering routes.\n     */\n    static forChild(routes: Routes): ModuleWithProviders<RouterModule>;\n}\nexport declare function createRouterScroller(router: Router, viewportScroller: ViewportScroller, config: ExtraOptions): RouterScroller;\nexport declare function provideLocationStrategy(platformLocationStrategy: PlatformLocation, baseHref: string, options?: ExtraOptions): HashLocationStrategy | PathLocationStrategy;\nexport declare function provideForRootGuard(router: Router): any;\n/**\n * @description\n *\n * Registers routes.\n *\n * @usageNotes\n * ### Example\n *\n * ```\n * @NgModule({\n *   imports: [RouterModule.forChild(ROUTES)],\n *   providers: [provideRoutes(EXTRA_ROUTES)]\n * })\n * class MyNgModule {}\n * ```\n *\n * @publicApi\n */\nexport declare function provideRoutes(routes: Routes): any;\n/**\n * @description\n *\n * Represents an option to configure when the initial navigation is performed.\n *\n * * 'enabled' - the initial navigation starts before the root component is created.\n * The bootstrap is blocked until the initial navigation is complete.\n * * 'disabled' - the initial navigation is not performed. The location listener is set up before\n * the root component gets created.\n * * 'legacy_enabled'- the initial navigation starts after the root component has been created.\n * The bootstrap is not blocked until the initial navigation is complete. @deprecated\n * * 'legacy_disabled'- the initial navigation is not performed. The location listener is set up\n * after @deprecated\n * the root component gets created.\n * * `true` - same as 'legacy_enabled'. @deprecated since v4\n * * `false` - same as 'legacy_disabled'. @deprecated since v4\n *\n * The 'enabled' option should be used for applications unless there is a reason to have\n * more control over when the router starts its initial navigation due to some complex\n * initialization logic. In this case, 'disabled' should be used.\n *\n * The 'legacy_enabled' and 'legacy_disabled' should not be used for new applications.\n *\n * @publicApi\n */\nexport declare type InitialNavigation = true | false | 'enabled' | 'disabled' | 'legacy_enabled' | 'legacy_disabled';\n/**\n * @description\n *\n * Represents options to configure the router.\n *\n * @publicApi\n */\nexport interface ExtraOptions {\n    /**\n     * Makes the router log all its internal events to the console.\n     */\n    enableTracing?: boolean;\n    /**\n     * Enables the location strategy that uses the URL fragment instead of the history API.\n     */\n    useHash?: boolean;\n    /**\n     * Disables the initial navigation.\n     */\n    initialNavigation?: InitialNavigation;\n    /**\n     * A custom error handler.\n     */\n    errorHandler?: ErrorHandler;\n    /**\n     * Configures a preloading strategy. See `PreloadAllModules`.\n     */\n    preloadingStrategy?: any;\n    /**\n     * Define what the router should do if it receives a navigation request to the current URL.\n     * By default, the router will ignore this navigation. However, this prevents features such\n     * as a \"refresh\" button. Use this option to configure the behavior when navigating to the\n     * current URL. Default is 'ignore'.\n     */\n    onSameUrlNavigation?: 'reload' | 'ignore';\n    /**\n     * Configures if the scroll position needs to be restored when navigating back.\n     *\n     * * 'disabled'--does nothing (default).  Scroll position will be maintained on navigation.\n     * * 'top'--set the scroll position to x = 0, y = 0 on all navigation.\n     * * 'enabled'--restores the previous scroll position on backward navigation, else sets the\n     * position to the anchor if one is provided, or sets the scroll position to [0, 0] (forward\n     * navigation). This option will be the default in the future.\n     *\n     * You can implement custom scroll restoration behavior by adapting the enabled behavior as\n     * follows:\n     * ```typescript\n     * class AppModule {\n      *   constructor(router: Router, viewportScroller: ViewportScroller) {\n      *     router.events.pipe(\n      *       filter((e: Event): e is Scroll => e instanceof Scroll)\n      *     ).subscribe(e => {\n      *       if (e.position) {\n      *         // backward navigation\n      *         viewportScroller.scrollToPosition(e.position);\n      *       } else if (e.anchor) {\n      *         // anchor navigation\n      *         viewportScroller.scrollToAnchor(e.anchor);\n      *       } else {\n      *         // forward navigation\n      *         viewportScroller.scrollToPosition([0, 0]);\n      *       }\n      *     });\n      *   }\n      * }\n      * ```\n     */\n    scrollPositionRestoration?: 'disabled' | 'enabled' | 'top';\n    /**\n     * Configures if the router should scroll to the element when the url has a fragment.\n     *\n     * * 'disabled'--does nothing (default).\n     * * 'enabled'--scrolls to the element. This option will be the default in the future.\n     *\n     * Anchor scrolling does not happen on 'popstate'. Instead, we restore the position\n     * that we stored or scroll to the top.\n     */\n    anchorScrolling?: 'disabled' | 'enabled';\n    /**\n     * Configures the scroll offset the router will use when scrolling to an element.\n     *\n     * When given a tuple with two numbers, the router will always use the numbers.\n     * When given a function, the router will invoke the function every time it restores scroll\n     * position.\n     */\n    scrollOffset?: [number, number] | (() => [number, number]);\n    /**\n     * Defines how the router merges params, data and resolved data from parent to child\n     * routes. Available options are:\n     *\n     * - `'emptyOnly'`, the default, only inherits parent params for path-less or component-less\n     *   routes.\n     * - `'always'`, enables unconditional inheritance of parent params.\n     */\n    paramsInheritanceStrategy?: 'emptyOnly' | 'always';\n    /**\n     * A custom malformed uri error handler function. This handler is invoked when encodedURI contains\n     * invalid character sequences. The default implementation is to redirect to the root url dropping\n     * any path or param info. This function passes three parameters:\n     *\n     * - `'URIError'` - Error thrown when parsing a bad URL\n     * - `'UrlSerializer'` - UrlSerializer thatâ€™s configured with the router.\n     * - `'url'` -  The malformed URL that caused the URIError\n     * */\n    malformedUriErrorHandler?: (error: URIError, urlSerializer: UrlSerializer, url: string) => UrlTree;\n    /**\n     * Defines when the router updates the browser URL. The default behavior is to update after\n     * successful navigation. However, some applications may prefer a mode where the URL gets\n     * updated at the beginning of navigation. The most common use case would be updating the\n     * URL early so if navigation fails, you can show an error message with the URL that failed.\n     * Available options are:\n     *\n     * - `'deferred'`, the default, updates the browser URL after navigation has finished.\n     * - `'eager'`, updates browser URL at the beginning of navigation.\n     */\n    urlUpdateStrategy?: 'deferred' | 'eager';\n    /**\n     * Enables a bug fix that corrects relative link resolution in components with empty paths.\n     * Example:\n     *\n     * ```\n     * const routes = [\n     *   {\n     *     path: '',\n     *     component: ContainerComponent,\n     *     children: [\n     *       { path: 'a', component: AComponent },\n     *       { path: 'b', component: BComponent },\n     *     ]\n     *   }\n     * ];\n     * ```\n     *\n     * From the `ContainerComponent`, this will not work:\n     *\n     * `<a [routerLink]=\"['./a']\">Link to A</a>`\n     *\n     * However, this will work:\n     *\n     * `<a [routerLink]=\"['../a']\">Link to A</a>`\n     *\n     * In other words, you're required to use `../` rather than `./`. This is currently the default\n     * behavior. Setting this option to `corrected` enables the fix.\n     */\n    relativeLinkResolution?: 'legacy' | 'corrected';\n}\nexport declare function setupRouter(ref: ApplicationRef, urlSerializer: UrlSerializer, contexts: ChildrenOutletContexts, location: Location, injector: Injector, loader: NgModuleFactoryLoader, compiler: Compiler, config: Route[][], opts?: ExtraOptions, urlHandlingStrategy?: UrlHandlingStrategy, routeReuseStrategy?: RouteReuseStrategy): Router;\nexport declare function rootRoute(router: Router): ActivatedRoute;\n/**\n * To initialize the router properly we need to do in two steps:\n *\n * We need to start the navigation in a APP_INITIALIZER to block the bootstrap if\n * a resolver or a guards executes asynchronously. Second, we need to actually run\n * activation in a BOOTSTRAP_LISTENER. We utilize the afterPreactivation\n * hook provided by the router to do that.\n *\n * The router navigation starts, reaches the point when preactivation is done, and then\n * pauses. It waits for the hook to be resolved. We then resolve it only in a bootstrap listener.\n */\nexport declare class RouterInitializer {\n    private injector;\n    private initNavigation;\n    private resultOfPreactivationDone;\n    constructor(injector: Injector);\n    appInitializer(): Promise<any>;\n    bootstrapListener(bootstrappedComponentRef: ComponentRef<any>): void;\n    private isLegacyEnabled;\n    private isLegacyDisabled;\n}\nexport declare function getAppInitializer(r: RouterInitializer): any;\nexport declare function getBootstrapListener(r: RouterInitializer): any;\n/**\n * A token for the router initializer that will be called after the app is bootstrapped.\n *\n * @publicApi\n */\nexport declare const ROUTER_INITIALIZER: InjectionToken<(compRef: ComponentRef<any>) => void>;\nexport declare function provideRouterInitializer(): (typeof RouterInitializer | {\n    provide: InjectionToken<(() => void)[]>;\n    multi: boolean;\n    useFactory: typeof getAppInitializer;\n    deps: (typeof RouterInitializer)[];\n    useExisting?: undefined;\n} | {\n    provide: InjectionToken<(compRef: ComponentRef<any>) => void>;\n    useFactory: typeof getBootstrapListener;\n    deps: (typeof RouterInitializer)[];\n    multi?: undefined;\n    useExisting?: undefined;\n} | {\n    provide: InjectionToken<((compRef: ComponentRef<any>) => void)[]>;\n    multi: boolean;\n    useExisting: InjectionToken<(compRef: ComponentRef<any>) => void>;\n    useFactory?: undefined;\n    deps?: undefined;\n})[];\n"]}