{"version":3,"file":"interceptor.d.ts","sources":["interceptor.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { InjectionToken } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { HttpHandler } from './backend';\nimport { HttpRequest } from './request';\nimport { HttpEvent } from './response';\n/**\n * Intercepts `HttpRequest` or `HttpResponse` and handles them.\n *\n * Most interceptors transform the outgoing request before passing it to the\n * next interceptor in the chain, by calling `next.handle(transformedReq)`.\n * An interceptor may transform the\n * response event stream as well, by applying additional RxJS operators on the stream\n * returned by `next.handle()`.\n *\n * More rarely, an interceptor may handle the request entirely,\n * and compose a new event stream instead of invoking `next.handle()`. This is an\n * acceptable behavior, but keep in mind that further interceptors will be skipped entirely.\n *\n * It is also rare but valid for an interceptor to return multiple responses on the\n * event stream for a single request.\n *\n * @publicApi\n *\n * @see [HTTP Guide](guide/http#intercepting-requests-and-responses)\n *\n * @usageNotes\n *\n * To use the same instance of `HttpInterceptors` for the entire app, import the `HttpClientModule`\n * only in your `AppModule`, and add the interceptors to the root application injector .\n * If you import `HttpClientModule` multiple times across different modules (for example, in lazy\n * loading modules), each import creates a new copy of the `HttpClientModule`, which overwrites the interceptors\n * provided in the root module.\n *\n */\nexport interface HttpInterceptor {\n    /**\n     * * **req**: The outgoing request to handle\n     * * **next**: The next interceptor in the chain, or the backend if no interceptors in the chain.\n     *\n     */\n    intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>>;\n}\n/**\n * `HttpHandler` which applies an `HttpInterceptor` to an `HttpRequest`.\n *\n *\n */\nexport declare class HttpInterceptorHandler implements HttpHandler {\n    private next;\n    private interceptor;\n    constructor(next: HttpHandler, interceptor: HttpInterceptor);\n    handle(req: HttpRequest<any>): Observable<HttpEvent<any>>;\n}\n/**\n * A multi-provider token which represents the array of `HttpInterceptor`s that\n * are registered.\n *\n * @publicApi\n */\nexport declare const HTTP_INTERCEPTORS: InjectionToken<HttpInterceptor[]>;\nexport declare class NoopInterceptor implements HttpInterceptor {\n    intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>>;\n}\n"]}