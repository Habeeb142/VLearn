'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var core$1 = require('@angular/core');
var core = require('@ionic-native/core');

exports.OCRSourceType = void 0;
(function (OCRSourceType) {
    /**
     * Normal processing from a file URL. This is the overall recommended choice
     * for most applications. The distinction between file and native URLs is
     * only relevant on iOS; under Android `NORMFILEURL` and `NORMNATIVEURL`
     * are interchangeable.
     */
    OCRSourceType[OCRSourceType["NORMFILEURL"] = 0] = "NORMFILEURL";
    /**
     * Normal processing from a native URL. Since this source type uses deprecated
     * OS APIs to interact with the camera plugin, it is best avoided, especially
     * if ongoing forward compatibility is a concern. For further information, see
     * https://github.com/NeutrinosPlatform/cordova-plugin-mobile-ocr#plugin-usage
     * Under Android, this is equivalent to `NORMFILEURL`.
     */
    OCRSourceType[OCRSourceType["NORMNATIVEURL"] = 1] = "NORMNATIVEURL";
    /**
     * Fast processing from a file URL. As the compression done internally causes
     * a significant loss in extraction quality, it should only be preferred when
     * dealing with large images containing significant amounts of text, where
     * the execution time required to perform normal processing is prohibitive.
     * The distinction between file and native URLs is only relevant on iOS;
     * under Android `FASTFILEURL` and `FASTNATIVEURL` are interchangeable.
     */
    OCRSourceType[OCRSourceType["FASTFILEURL"] = 2] = "FASTFILEURL";
    /**
     * Fast processing from a native URL. See comments above for `FASTFILEURL`
     * concerning quality loss.
     *
     * The distinction between file and native URLs is only relevant on iOS;
     * under Android `FASTFILEURL` and `FASTNATIVEURL` are interchangeable.
     */
    OCRSourceType[OCRSourceType["FASTNATIVEURL"] = 3] = "FASTNATIVEURL";
    /**
     * Normal processing from a base64-encoded string. Quality is equivalent
     * to `NORMFILEURL`, but due to significantly higher memory requirements,
     * is only appropriate for use with very small images.
     */
    OCRSourceType[OCRSourceType["BASE64"] = 4] = "BASE64";
})(exports.OCRSourceType || (exports.OCRSourceType = {}));
var ɵngcc0 = require('@angular/core');
var OCR = /** @class */ (function (_super) {
    tslib.__extends(OCR, _super);
    function OCR() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    OCR.prototype.recText = function (sourceType, source) { return core.cordova(this, "recText", {}, arguments); };
    OCR.pluginName = "OCR";
    OCR.plugin = "cordova-plugin-mobile-ocr";
    OCR.pluginRef = "textocr";
    OCR.repo = "https://github.com/NeutrinosPlatform/cordova-plugin-mobile-ocr";
    OCR.platforms = ["Android", "iOS"];
OCR.ɵfac = function OCR_Factory(t) { return ɵOCR_BaseFactory(t || OCR); };
OCR.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: OCR, factory: function (t) { return OCR.ɵfac(t); } });
var ɵOCR_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(OCR);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(OCR, [{
        type: core$1.Injectable
    }], null, null); })();
    return OCR;
}(core.IonicNativePlugin));

exports.OCR = OCR;

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlcyI6WyJidW5kbGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OzBCQUdNO0FBQ047QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciB0c2xpYiA9IHJlcXVpcmUoJ3RzbGliJyk7XG52YXIgY29yZSQxID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIGNvcmUgPSByZXF1aXJlKCdAaW9uaWMtbmF0aXZlL2NvcmUnKTtcblxuZXhwb3J0cy5PQ1JTb3VyY2VUeXBlID0gdm9pZCAwO1xuKGZ1bmN0aW9uIChPQ1JTb3VyY2VUeXBlKSB7XG4gICAgLyoqXG4gICAgICogTm9ybWFsIHByb2Nlc3NpbmcgZnJvbSBhIGZpbGUgVVJMLiBUaGlzIGlzIHRoZSBvdmVyYWxsIHJlY29tbWVuZGVkIGNob2ljZVxuICAgICAqIGZvciBtb3N0IGFwcGxpY2F0aW9ucy4gVGhlIGRpc3RpbmN0aW9uIGJldHdlZW4gZmlsZSBhbmQgbmF0aXZlIFVSTHMgaXNcbiAgICAgKiBvbmx5IHJlbGV2YW50IG9uIGlPUzsgdW5kZXIgQW5kcm9pZCBgTk9STUZJTEVVUkxgIGFuZCBgTk9STU5BVElWRVVSTGBcbiAgICAgKiBhcmUgaW50ZXJjaGFuZ2VhYmxlLlxuICAgICAqL1xuICAgIE9DUlNvdXJjZVR5cGVbT0NSU291cmNlVHlwZVtcIk5PUk1GSUxFVVJMXCJdID0gMF0gPSBcIk5PUk1GSUxFVVJMXCI7XG4gICAgLyoqXG4gICAgICogTm9ybWFsIHByb2Nlc3NpbmcgZnJvbSBhIG5hdGl2ZSBVUkwuIFNpbmNlIHRoaXMgc291cmNlIHR5cGUgdXNlcyBkZXByZWNhdGVkXG4gICAgICogT1MgQVBJcyB0byBpbnRlcmFjdCB3aXRoIHRoZSBjYW1lcmEgcGx1Z2luLCBpdCBpcyBiZXN0IGF2b2lkZWQsIGVzcGVjaWFsbHlcbiAgICAgKiBpZiBvbmdvaW5nIGZvcndhcmQgY29tcGF0aWJpbGl0eSBpcyBhIGNvbmNlcm4uIEZvciBmdXJ0aGVyIGluZm9ybWF0aW9uLCBzZWVcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vTmV1dHJpbm9zUGxhdGZvcm0vY29yZG92YS1wbHVnaW4tbW9iaWxlLW9jciNwbHVnaW4tdXNhZ2VcbiAgICAgKiBVbmRlciBBbmRyb2lkLCB0aGlzIGlzIGVxdWl2YWxlbnQgdG8gYE5PUk1GSUxFVVJMYC5cbiAgICAgKi9cbiAgICBPQ1JTb3VyY2VUeXBlW09DUlNvdXJjZVR5cGVbXCJOT1JNTkFUSVZFVVJMXCJdID0gMV0gPSBcIk5PUk1OQVRJVkVVUkxcIjtcbiAgICAvKipcbiAgICAgKiBGYXN0IHByb2Nlc3NpbmcgZnJvbSBhIGZpbGUgVVJMLiBBcyB0aGUgY29tcHJlc3Npb24gZG9uZSBpbnRlcm5hbGx5IGNhdXNlc1xuICAgICAqIGEgc2lnbmlmaWNhbnQgbG9zcyBpbiBleHRyYWN0aW9uIHF1YWxpdHksIGl0IHNob3VsZCBvbmx5IGJlIHByZWZlcnJlZCB3aGVuXG4gICAgICogZGVhbGluZyB3aXRoIGxhcmdlIGltYWdlcyBjb250YWluaW5nIHNpZ25pZmljYW50IGFtb3VudHMgb2YgdGV4dCwgd2hlcmVcbiAgICAgKiB0aGUgZXhlY3V0aW9uIHRpbWUgcmVxdWlyZWQgdG8gcGVyZm9ybSBub3JtYWwgcHJvY2Vzc2luZyBpcyBwcm9oaWJpdGl2ZS5cbiAgICAgKiBUaGUgZGlzdGluY3Rpb24gYmV0d2VlbiBmaWxlIGFuZCBuYXRpdmUgVVJMcyBpcyBvbmx5IHJlbGV2YW50IG9uIGlPUztcbiAgICAgKiB1bmRlciBBbmRyb2lkIGBGQVNURklMRVVSTGAgYW5kIGBGQVNUTkFUSVZFVVJMYCBhcmUgaW50ZXJjaGFuZ2VhYmxlLlxuICAgICAqL1xuICAgIE9DUlNvdXJjZVR5cGVbT0NSU291cmNlVHlwZVtcIkZBU1RGSUxFVVJMXCJdID0gMl0gPSBcIkZBU1RGSUxFVVJMXCI7XG4gICAgLyoqXG4gICAgICogRmFzdCBwcm9jZXNzaW5nIGZyb20gYSBuYXRpdmUgVVJMLiBTZWUgY29tbWVudHMgYWJvdmUgZm9yIGBGQVNURklMRVVSTGBcbiAgICAgKiBjb25jZXJuaW5nIHF1YWxpdHkgbG9zcy5cbiAgICAgKlxuICAgICAqIFRoZSBkaXN0aW5jdGlvbiBiZXR3ZWVuIGZpbGUgYW5kIG5hdGl2ZSBVUkxzIGlzIG9ubHkgcmVsZXZhbnQgb24gaU9TO1xuICAgICAqIHVuZGVyIEFuZHJvaWQgYEZBU1RGSUxFVVJMYCBhbmQgYEZBU1ROQVRJVkVVUkxgIGFyZSBpbnRlcmNoYW5nZWFibGUuXG4gICAgICovXG4gICAgT0NSU291cmNlVHlwZVtPQ1JTb3VyY2VUeXBlW1wiRkFTVE5BVElWRVVSTFwiXSA9IDNdID0gXCJGQVNUTkFUSVZFVVJMXCI7XG4gICAgLyoqXG4gICAgICogTm9ybWFsIHByb2Nlc3NpbmcgZnJvbSBhIGJhc2U2NC1lbmNvZGVkIHN0cmluZy4gUXVhbGl0eSBpcyBlcXVpdmFsZW50XG4gICAgICogdG8gYE5PUk1GSUxFVVJMYCwgYnV0IGR1ZSB0byBzaWduaWZpY2FudGx5IGhpZ2hlciBtZW1vcnkgcmVxdWlyZW1lbnRzLFxuICAgICAqIGlzIG9ubHkgYXBwcm9wcmlhdGUgZm9yIHVzZSB3aXRoIHZlcnkgc21hbGwgaW1hZ2VzLlxuICAgICAqL1xuICAgIE9DUlNvdXJjZVR5cGVbT0NSU291cmNlVHlwZVtcIkJBU0U2NFwiXSA9IDRdID0gXCJCQVNFNjRcIjtcbn0pKGV4cG9ydHMuT0NSU291cmNlVHlwZSB8fCAoZXhwb3J0cy5PQ1JTb3VyY2VUeXBlID0ge30pKTtcbnZhciBPQ1IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKE9DUiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBPQ1IoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT0NSLnByb3RvdHlwZS5yZWNUZXh0ID0gZnVuY3Rpb24gKHNvdXJjZVR5cGUsIHNvdXJjZSkgeyByZXR1cm4gY29yZS5jb3Jkb3ZhKHRoaXMsIFwicmVjVGV4dFwiLCB7fSwgYXJndW1lbnRzKTsgfTtcbiAgICBPQ1IucGx1Z2luTmFtZSA9IFwiT0NSXCI7XG4gICAgT0NSLnBsdWdpbiA9IFwiY29yZG92YS1wbHVnaW4tbW9iaWxlLW9jclwiO1xuICAgIE9DUi5wbHVnaW5SZWYgPSBcInRleHRvY3JcIjtcbiAgICBPQ1IucmVwbyA9IFwiaHR0cHM6Ly9naXRodWIuY29tL05ldXRyaW5vc1BsYXRmb3JtL2NvcmRvdmEtcGx1Z2luLW1vYmlsZS1vY3JcIjtcbiAgICBPQ1IucGxhdGZvcm1zID0gW1wiQW5kcm9pZFwiLCBcImlPU1wiXTtcbiAgICBPQ1IuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlJDEuSW5qZWN0YWJsZSB9XG4gICAgXTtcbiAgICByZXR1cm4gT0NSO1xufShjb3JlLklvbmljTmF0aXZlUGx1Z2luKSk7XG5cbmV4cG9ydHMuT0NSID0gT0NSO1xuIl19